import dotenv from 'dotenv';
import express from 'express';
import mongoose from 'mongoose';
import cors from 'cors';
import { v2 as cloudinary } from 'cloudinary';
import multer from 'multer';
import connectDB from './connection.js';
import { Profile, Image, Transaction, DownloadToken } from './models.js';
import serverless from 'serverless-http';

// Load environment variables
dotenv.config({
  path: '../.env'  // Look for .env in parent directory
});

// Configure Cloudinary
cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

// Configure multer for memory storage
const storage = multer.memoryStorage();
const upload = multer({ storage });

const app = express();

// Middleware
// CORS configuration
// Allow production host and common local dev origins (include Vite fallback port 5174)
const devOrigins = [
  'http://localhost:5173',
  'http://127.0.0.1:5173',
  'http://localhost:5174',
  'http://127.0.0.1:5174',
];

app.use(cors({
  origin: (origin, callback) => {
    // Allow non-browser (server-to-server) requests with no origin
    if (!origin) return callback(null, true);

    if (process.env.NODE_ENV === 'production') {
      // In production allow requests from the deployed Netlify site(s).
      // Accept any Netlify-hosted site under the same account by allowing
      // origins that end with `.netlify.app`. This is more flexible than
      // hardcoding a single hostname and avoids mismatches during deploys.
      try {
        const isNetlify = origin.endsWith('.netlify.app');
        if (isNetlify) return callback(null, true);
      } catch (e) {
        // If origin is somehow malformed, deny by default
        return callback(null, false);
      }
      // Otherwise deny
      return callback(null, false);
    }

    // Development: allow local dev origins
    return devOrigins.includes(origin) ? callback(null, true) : callback(null, false);
  },
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
}));

// Ensure preflight requests are handled
app.options('*', cors());

app.use(express.json({ limit: '200mb' }));
app.use(express.urlencoded({ limit: '200mb', extended: true }));

// Connect to database
connectDB();

// Path alias middleware to support both /api and /.netlify/functions/server paths
app.use((req, res, next) => {
  if (req.path.startsWith('/api/')) {
    console.log(`[Route] Rewriting ${req.path} to /.netlify/functions/server/*`);
    req.url = req.url.replace(/^\/api/, '/.netlify/functions/server');
  }
  next();
});

// Get all images with pagination
app.get('/.netlify/functions/server/images', async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 20;
    const skip = (page - 1) * limit;

    const [images, total] = await Promise.all([
      Image.find()
        .sort({ created_at: -1 })
        .skip(skip)
        .limit(limit)
        .populate('creator_id', 'name profilePicture'),
      Image.countDocuments()
    ]);

    const pages = Math.ceil(total / limit);

    res.json({
      images,
      pagination: {
        page,
        pages,
        total
      }
    });
  } catch (error) {
    console.error('[Images] Error fetching all:', error);
    res.status(500).json({ error: error.message });
  }
});

// Transactions
app.get('/.netlify/functions/server/transactions', async (req, res) => {
  try {
    const transactions = await Transaction.find();
    res.json(transactions);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.get('/.netlify/functions/server/transactions/creator/:creatorId', async (req, res) => {
  try {
    console.log(`[Transactions] Fetching for creator: ${req.params.creatorId}`);
    const transactions = await Transaction.find({ creator_id: req.params.creatorId });
    res.json(transactions);
  } catch (error) {
    console.error('[Transactions] Error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Images
app.post('/.netlify/functions/server/images', async (req, res) => {
  try {
    console.log('[Images] Creating new image:', req.body);
    const image = new Image({
      ...req.body,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    });
    await image.save();
    console.log('[Images] Created:', image);
    res.status(201).json(image);
  } catch (error) {
    console.error('[Images] Error creating:', error);
    res.status(400).json({ error: error.message });
  }
});

app.get('/.netlify/functions/server/images/creator/:creatorId', async (req, res) => {
  try {
    console.log(`[Images] Fetching for creator: ${req.params.creatorId}`);
    const images = await Image.find({ creator_id: req.params.creatorId })
      .sort({ created_at: -1 });
    res.json(images);
  } catch (error) {
    console.error('[Images] Error:', error);
    res.status(500).json({ error: error.message });
  }
});

app.get('/.netlify/functions/server/images/:id', async (req, res) => {
  try {
    const image = await Image.findById(req.params.id);
    if (!image) return res.status(404).json({ error: 'Image not found' });
    res.json(image);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.put('/.netlify/functions/server/images/:id', async (req, res) => {
  try {
    const image = await Image.findById(req.params.id);
    if (!image) return res.status(404).json({ error: 'Image not found' });
    Object.assign(image, { ...req.body, updated_at: new Date().toISOString() });
    await image.save();
    res.json(image);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.delete('/.netlify/functions/server/images/:id', async (req, res) => {
  try {
    const image = await Image.findById(req.params.id);
    if (!image) return res.status(404).json({ error: 'Image not found' });
    await image.deleteOne();
    res.json({ message: 'Image deleted successfully' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.post('/.netlify/functions/server/transactions', async (req, res) => {
  try {
    const transaction = new Transaction({
      ...req.body,
      created_at: new Date().toISOString()
    });
    await transaction.save();
    res.status(201).json(transaction);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Helper function to upload to Cloudinary
const uploadToCloudinary = (buffer, folder, publicId) => {
  return new Promise((resolve, reject) => {
    console.log(`Attempting Cloudinary upload: ${folder}/${publicId}`);
    
    const uploadOptions = {
      folder,
      public_id: publicId,
      resource_type: 'auto',
      overwrite: true,
      invalidate: true,
    };

    const stream = cloudinary.uploader.upload_stream(
      uploadOptions,
      (error, result) => {
        if (error) {
          console.error('Cloudinary upload failed:', {
            folder,
            publicId,
            error: error.message,
            code: error.http_code
          });
          reject(new Error(`Cloudinary upload failed: ${error.message}`));
        } else {
          console.log('Cloudinary upload successful:', {
            folder,
            publicId,
            url: result.secure_url
          });
          resolve(result);
        }
      }
    );

    // Handle stream errors
    stream.on('error', (error) => {
      console.error('Stream error during upload:', error);
      reject(new Error('Stream error during upload'));
    });

    try {
      stream.end(buffer);
    } catch (error) {
      console.error('Error writing to stream:', error);
      reject(new Error('Error writing to upload stream'));
    }
  });
};

// Routes
app.get('/.netlify/functions/server', (req, res) => {
  res.json({ message: 'API is working!' });
});

// Health check - returns server + DB status
app.get('/.netlify/functions/server/health', (req, res) => {
  const dbState = mongoose.connection ? mongoose.connection.readyState : 0;
  // readyState: 0 = disconnected, 1 = connected, 2 = connecting, 3 = disconnecting
  res.json({ status: 'ok', db: { readyState: dbState } });
});

// Helper function to upload to Cloudinary with timeout
const uploadToCloudinaryWithTimeout = async (buffer, folder, publicId) => {
  return Promise.race([
    new Promise((_, reject) => 
      setTimeout(() => reject(new Error('Upload timeout')), 25000)
    ),
    new Promise((resolve, reject) => {
      cloudinary.uploader
        .upload_stream(
          {
            folder,
            public_id: publicId,
            resource_type: 'auto',
          },
          (error, result) => {
            if (error) reject(error);
            else resolve(result);
          }
        )
        .end(buffer);
    }),
  ]);
};

// Upload image endpoint
app.post('/.netlify/functions/server/upload', upload.fields([
  { name: 'image', maxCount: 1 },
  { name: 'thumbnail', maxCount: 1 }
]), async (req, res) => {
  console.log('Upload request received:', {
    files: req.files ? Object.keys(req.files) : 'no files',
    contentType: req.headers['content-type'],
    cloudinary: {
      cloudName: process.env.CLOUDINARY_CLOUD_NAME ? 'set' : 'missing',
      apiKey: process.env.CLOUDINARY_API_KEY ? 'set' : 'missing',
      apiSecret: process.env.CLOUDINARY_API_SECRET ? 'set' : 'missing'
    }
  });

  try {
    // Verify Cloudinary configuration
    if (!process.env.CLOUDINARY_CLOUD_NAME || !process.env.CLOUDINARY_API_KEY || !process.env.CLOUDINARY_API_SECRET) {
      const error = 'Cloudinary configuration incomplete. Please check environment variables.';
      console.error(error, {
        cloudName: !!process.env.CLOUDINARY_CLOUD_NAME,
        apiKey: !!process.env.CLOUDINARY_API_KEY,
        apiSecret: !!process.env.CLOUDINARY_API_SECRET
      });
      return res.status(500).json({ error });
    }

    // Initial request validation
    if (!req.files || (!req.files.image?.length && !req.files.thumbnail?.length)) {
      const error = 'No files were uploaded';
      console.error(error, { 
        files: req.files ? Object.keys(req.files) : 'none',
        image: req.files?.image?.length || 0,
        thumbnail: req.files?.thumbnail?.length || 0
      });
      return res.status(400).json({ error });
    }

    const { image, thumbnail } = req.files;

    // Validate both files are present
    if (!image?.[0] || !thumbnail?.[0]) {
      console.error('Missing required files:', { 
        hasImage: !!image?.[0], 
        hasThumbnail: !!thumbnail?.[0],
        imageDetails: image?.[0] ? { size: image[0].size, type: image[0].mimetype } : 'missing',
        thumbnailDetails: thumbnail?.[0] ? { size: thumbnail[0].size, type: thumbnail[0].mimetype } : 'missing'
      });
      return res.status(400).json({
        error: 'Both image and thumbnail are required',
        received: {
          image: !!image?.[0],
          thumbnail: !!thumbnail?.[0]
        }
      });
    }

    // Validate file sizes (10MB limit)
    const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB
    for (const [fieldname, files] of Object.entries(req.files)) {
      const file = files[0];
      if (file.size > MAX_FILE_SIZE) {
        const error = `${fieldname} file size exceeds 10MB limit`;
        console.warn(error, {
          fieldname,
          size: file.size,
          limit: MAX_FILE_SIZE
        });
        return res.status(400).json({ error });
      }
    }

    // Validate file types
    const allowedMimeTypes = ['image/jpeg', 'image/png', 'image/webp'];
    for (const [fieldname, files] of Object.entries(req.files)) {
      const file = files[0];
      if (!allowedMimeTypes.includes(file.mimetype)) {
        const error = `Invalid file type for ${fieldname}. Only JPEG, PNG, and WebP images are allowed.`;
        console.warn(error, {
          fieldname,
          mimetype: file.mimetype,
          allowedTypes: allowedMimeTypes
        });
        return res.status(400).json({ error });
      }
    }

    console.log('Files validated successfully:', {
      image: { size: image[0].size, mimetype: image[0].mimetype },
      thumbnail: { size: thumbnail[0].size, mimetype: thumbnail[0].mimetype }
    });

    // Generate unique IDs for Cloudinary
    const timestamp = Date.now();
    const randomId = Math.random().toString(36).substr(2, 9);
    const imagePublicId = `images/${timestamp}-${randomId}-img`;
    const thumbnailPublicId = `thumbnails/${timestamp}-${randomId}-thumb`;

    try {
      // Upload to Cloudinary
      console.log('Initiating Cloudinary upload...');
      const [imageResult, thumbnailResult] = await Promise.all([
        uploadToCloudinaryWithTimeout(image[0].buffer, 'images', imagePublicId),
        uploadToCloudinaryWithTimeout(thumbnail[0].buffer, 'thumbnails', thumbnailPublicId),
      ]);

      console.log('Upload successful:', {
        image: imageResult.secure_url,
        thumbnail: thumbnailResult.secure_url
      });

      // Always send response with content
      return res.status(200).json({
        success: true,
        image_url: imageResult.secure_url,
        thumbnail_url: thumbnailResult.secure_url
      });
    } catch (uploadError) {
      console.error('Cloudinary upload error:', uploadError);
      return res.status(500).json({
        error: 'Failed to upload to Cloudinary',
        details: uploadError.message
      });
    }

  } catch (error) {
    // Log error with detailed context
    console.error('Upload error:', {
      message: error.message,
      stack: error.stack,
      requestFiles: req.files ? {
        image: req.files.image?.[0] ? {
          size: req.files.image[0].size,
          type: req.files.image[0].mimetype
        } : 'missing',
        thumbnail: req.files.thumbnail?.[0] ? {
          size: req.files.thumbnail[0].size,
          type: req.files.thumbnail[0].mimetype
        } : 'missing'
      } : 'no files',
      cloudinaryConfig: {
        isConfigured: !!(process.env.CLOUDINARY_CLOUD_NAME && process.env.CLOUDINARY_API_KEY && process.env.CLOUDINARY_API_SECRET)
      }
    });
    
    return res.status(500).json({
      error: 'Upload failed',
      details: error.message
    });
  }
});

// Get all profiles
app.get('/.netlify/functions/server/profiles', async (req, res) => {
  try {
    const profiles = await Profile.find();
    res.json(profiles);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Get profile by ID
app.get('/.netlify/functions/server/profiles/:id', async (req, res) => {
  try {
    console.log(`[GET Profile] Looking for profile with id: ${req.params.id}`);
    const profile = await Profile.findOne({ id: req.params.id });
    
    if (!profile) {
      console.log(`[GET Profile] Profile not found for id: ${req.params.id}`);
      return res.status(404).json({ 
        error: 'Profile not found',
        message: `No profile found with id: ${req.params.id}`,
        requestedId: req.params.id
      });
    }
    
    console.log(`[GET Profile] Found profile:`, profile);
    res.json(profile);
  } catch (error) {
    console.error(`[GET Profile] Error:`, error);
    res.status(500).json({ 
      error: 'Internal server error',
      message: error.message,
      stack: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
  }
});

// Create profile
app.post('/.netlify/functions/server/profiles', async (req, res) => {
  try {
    const profile = new Profile(req.body);
    await profile.save();
    res.status(201).json(profile);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Update profile
app.put('/.netlify/functions/server/profiles/:id', async (req, res) => {
  try {
    const profile = await Profile.findOneAndUpdate(
      { id: req.params.id },
      req.body,
      { new: true }
    );
    res.json(profile);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// --- Images endpoints (mirror of server.js /api/images) ---
// Get all images
app.get('/api/images', async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 20;
    const skip = (page - 1) * limit;

    const images = await Image.find()
      .populate('creator_id')
      .sort({ created_at: -1 })
      .skip(skip)
      .limit(limit);

    const total = await Image.countDocuments();

    res.json({
      images,
      pagination: {
        page,
        limit,
        total,
        pages: Math.ceil(total / limit)
      }
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Get image by ID
app.get('/api/images/:id', async (req, res) => {
  try {
    const image = await Image.findOne({ id: req.params.id });
    if (!image) return res.status(404).json({ error: 'Image not found' });
    res.json(image);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Get images by creator
app.get('/api/images/creator/:creatorId', async (req, res) => {
  try {
    const images = await Image.find({ creator_id: req.params.creatorId }).populate('creator_id');
    res.json(images);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Create image
app.post('/api/images', async (req, res) => {
  try {
    const image = new Image(req.body);
    await image.save();
    res.status(201).json(image);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Update image
app.put('/api/images/:id', async (req, res) => {
  try {
    const image = await Image.findOneAndUpdate(
      { id: req.params.id },
      req.body,
      { new: true }
    );
    if (!image) return res.status(404).json({ error: 'Image not found' });
    res.json(image);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Delete image
app.delete('/api/images/:id', async (req, res) => {
  try {
    const image = await Image.findOneAndDelete({ id: req.params.id });
    if (!image) return res.status(404).json({ error: 'Image not found' });
    res.json({ message: 'Image deleted successfully' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Export the serverless function
export const handler = serverless(app);

// Only start the server in development
if (process.env.NODE_ENV !== 'production') {
  const PORT = process.env.PORT || 5001;  // Changed to 5001
  app.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`);
  }).on('error', (error) => {
    if (error.code === 'EADDRINUSE') {
      console.log(`Port ${PORT} is busy, trying port ${PORT + 1}`);
      process.env.PORT = (PORT + 1).toString();
      app.listen(PORT + 1, () => {
        console.log(`Server running on port ${PORT + 1}`);
      });
    } else {
      console.error('Failed to start server:', error);
      process.exit(1);
    }
  });
}
  });
}